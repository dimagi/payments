# Stub models file
import calendar
import logging
import re
import urllib
from couchdbkit.ext.django.schema import *
import datetime
import decimal
import dateutil
from django.conf import settings
import urllib2
from django.utils.safestring import mark_safe
import phonenumbers
import pytz
from dimagi.utils.couch.database import get_db
from dimagi.utils.timezones import utils as tz_utils
from hqbilling.utils import get_mach_data, format_start_end_suffixes

DEFAULT_BASE = 0.02
ACTIVE_USER_RATE = 0.75
INCOMING = "I"
OUTGOING = "O"
SMS_DIRECTIONS = {
    INCOMING: "Incoming",
    OUTGOING: "Outgoing"
}

class HQMonthlyBill(Document):
    """
        This bill is auto-generated by a periodic celery task for the previous month
        starting at midnight on the first of each month.
    """
    domain = StringProperty()
    billing_period_start = DateTimeProperty()
    billing_period_end = DateTimeProperty()
    date_generated = DateTimeProperty()
    all_incoming_sms_billables = ListProperty()
    all_incoming_sms_billed = DecimalProperty(default=0)
    all_outgoing_sms_billables = ListProperty()
    all_outgoing_sms_billed = DecimalProperty(default=0)
    active_users = ListProperty()
    active_users_billed = DecimalProperty(default=0)
    paid = BooleanProperty(default=False)
    billing_currency = StringProperty() #

    @property
    def invoice_id(self):
        parts = list()
        parts_date_fmt = "%m%d%Y"
        parts.append(self.domain.upper()[0:2])
        parts.append(self.billing_period_start.strftime(parts_date_fmt))
        parts.append(self.billing_period_end.strftime(parts_date_fmt))
        parts.append(self.date_generated.strftime(parts_date_fmt))
        return "".join(parts)

    @property
    def subtotal(self):
        return self.all_incoming_sms_billed + self.all_outgoing_sms_billed + self.active_users_billed

    @property
    def html_billing_address(self):
        from corehq.apps.domain.models import Domain
        domain = Domain.get_by_name(self.domain)
        if hasattr(domain, 'billing_address') and domain.billing_address:
            return domain.billing_address.html_address
        else:
            return mark_safe("""<address><strong>%s</strong><br />
                        No address available. Please ask project administrator to enter one.</address>""" % domain.name)

    @property
    def invoice_items(self):
        invoice_items = list()
        fmt_price = "$%.2f"
        if self.active_users_billed > 0:
            invoice_items.append(dict(
                desc="CommCare HQ Hosting Fees",
                qty="%d users" % len(self.active_users),
                unit_price=fmt_price % ACTIVE_USER_RATE,
                price = fmt_price % self.active_users_billed
            ))
        if self.all_incoming_sms_billed > 0:
            invoice_items.append(dict(
                desc="SMS Inbound",
                qty=len(self.all_incoming_sms_billables),
                unit_price="See Itemized",
                price=fmt_price % self.all_incoming_sms_billed
            ))
        if self.all_outgoing_sms_billed > 0:
            invoice_items.append(dict(
                desc="SMS Outbound",
                qty=len(self.all_outgoing_sms_billables),
                unit_price="See Itemized",
                price=fmt_price % self.all_outgoing_sms_billed
            ))
        return invoice_items

    def _get_all_active_and_submitted_users(self):
        """
            Active users are:
            1) All CommCareUser objects who have the is_active flag set to True at the time of this bill generation.
            2) All CommCareUser objects who have the is_active flag set to False at the time of this bill generation
                but have submitted things to CommCare HQ during the span of the billing period.
        """
        from corehq.apps.users.models import CommCareUser
        active_user_ids = [user.user_id for user in CommCareUser.by_domain(self.domain)]
        inactive_user_ids = [user.user_id for user in CommCareUser.by_domain(self.domain, is_active=False)]
        data = get_db().view('reports/all_submissions',
            reduce=False,
            startkey = [self.domain, self.billing_period_start.isoformat()],
            endkey = [self.domain, self.billing_period_end.isoformat()]
        ).all()
        submitted_user_ids = [item.get('value',{}).get('user_id') for item in data]
        inactive_submitted_user_ids = list(set([user_id for user_id in submitted_user_ids
                                                if user_id in inactive_user_ids]))
        return active_user_ids+inactive_submitted_user_ids

    @classmethod
    def base_couch_view(cls):
        return "hqbilling/monthly_bills"

    @classmethod
    def get_bills(cls, domain, prefix="start", paid=None, start=None, end=None, include_docs=True):
        extra = []
        if paid is not None:
            prefix = "%s paid"
        if paid is True:
            extra = ["yes"]
        elif paid is False:
            extra = ["no"]
        key = [prefix, domain]+extra
        startkey_suffix, endkey_suffix = format_start_end_suffixes(start, end)
        return cls.view(cls.base_couch_view(),
            include_docs=include_docs,
            reduce=False,
            startkey=key+startkey_suffix,
            endkey=key+endkey_suffix
        )

    @classmethod
    def create_bill_for_domain(cls, domain, billing_range=None):
        # billing_range is a tuple of datetimes with the first element as the beginning of the billing period and
        # the second element as the end
        start = billing_range[0] if billing_range else None
        end = billing_range[1] if billing_range else None
        if not (isinstance(start, datetime.datetime) and isinstance(stop, datetime.datetime)):
            start, end = cls.get_default_start_end()

        bill = cls(domain=domain)
        bill.domain = domain
        bill.billing_period_start = start
        bill.billing_period_end = end
        bill.date_generated = datetime.datetime.utcnow()

        all_incoming = SMSBillable.by_domain_and_direction(domain, INCOMING,
                            start=start.isoformat(), end=end.isoformat())
        all_incoming_ids, all_incoming_cost = cls.get_ids_and_cost(all_incoming)
        bill.alL_incoming_sms_billables = all_incoming_ids
        bill.all_incoming_sms_billed = all_incoming_cost

        all_outgoing = SMSBillable.by_domain_and_direction(domain, OUTGOING,
                            start=start.isoformat(), end=end.isoformat())
        all_outgoing_ids, all_outgoing_cost = cls.get_ids_and_cost(all_outgoing)
        bill.all_outgoing_sms_billables = all_outgoing_ids
        bill.all_outgoing_sms_billed = all_outgoing_cost

        active_users = bill._get_all_active_and_submitted_users()
        bill.active_users = active_users
        if len(active_users) > 20:
            bill.active_users_billed = len(active_users)*ACTIVE_USER_RATE

        if bill.all_incoming_sms_billed > 0 or \
           bill.all_outgoing_sms_billed > 0 or \
           bill.active_users_billed > 0:
            bill.save() # save only the bills with costs attached
        return bill

    @staticmethod
    def get_ids_and_cost(billables):
        return [b.get_id for b in billables], sum([b.total_billed for b in billables])

    @staticmethod
    def get_default_start_end():
        today = datetime.datetime.utcnow()
        td = datetime.timedelta(days=14)
        two_weeks = today - td
        billing_month = two_weeks.month
        billing_year = two_weeks.year
        (_, last_day) = calendar.monthrange(billing_year, billing_month)
        start_date = datetime.datetime(billing_year, billing_month, 1, 0, 0, 0, 0)
        end_date = datetime.datetime(billing_year, billing_month, last_day, 23, 59, 59, 999999)
        return start_date, end_date


class UpdatableItemMixin(object):
    """
        This is what the item updating reports will use to display/edit an item
    """
    @property
    def column_list(self):
        """
            Returns a list of properties that are going to be the columns of the row outputted
            in as_row.
        """
        raise NotImplementedError

    @property
    def as_row(self):
        keys = self.column_list
        row = []
        for key in keys:
            property = getattr(self, key)
            row.append(self._format_property(key, property))
        row.append(self.update_item_button)
        return row

    @property
    def update_item_button(self):
        return NotImplementedError

    def _format_property(self, key, property):
        if isinstance(property, decimal.Decimal):
            property = property.quantize(decimal.Decimal(10) ** -3)
            return "%s %s" % (self.currency_character, property)
        return property

    @staticmethod
    def couch_view():
        return NotImplementedError


class BillableCurrency(Document, UpdatableItemMixin):
    currency_code = StringProperty()
    conversion = DecimalProperty()
    source = StringProperty()
    last_updated = DateTimeProperty()

    @property
    def column_list(self):
        return ["currency_code", "conversion", "last_updated"]

    @property
    def update_item_button(self):
        return '<a href="#updateRateModal" class="btn" onclick="rateUpdateManager.updateRate(this)" data-rateid="%s" data-toggle="modal">Edit Currency</a>' % self._id

    def update_conversion_rate(self):
        self.last_updated = datetime.datetime.utcnow()
        default_currency = settings.DEFAULT_CURRENCY.upper()
        if self.currency_code == default_currency:
            self.conversion = 1.0
            self.source = "default"
            return

        conversion_url = "http://www.google.com/ig/calculator?hl=en&q=1%s=?%s" %\
                         (self.currency_code, default_currency)

        try:
            data = urllib2.urlopen(conversion_url).read()
            # AGH GOOGLE WHY DON'T YOU RETURN VALID JSON??? ?#%!%!%@#
            rhs = re.compile('rhs:\s*"([^"]+)"')
            data = rhs.search(data).group()
            cur = re.compile('[0-9.]+')
            data = cur.search(data).group()
            self.conversion = float(data)
        except Exception as e:
            self.conversion = 0.0
            conversion_url = "ERROR: %s, %s" % (e, conversion_url)
        self.source = conversion_url

    @classmethod
    def get_by_code(cls, currency_code, include_docs=True):
        key = [currency_code.upper()]
        return cls.view(cls.couch_view(),
            reduce=False,
            include_docs=include_docs,
            startkey=key,
            endkey=key+[{}]
        )

    @classmethod
    def get_existing_or_new_by_code(cls, currency_code):
        currency = cls.get_by_code(currency_code).first()
        if not currency:
            currency = cls(currency_code=currency_code.upper())
            currency.save()
        return currency

    @staticmethod
    def couch_view():
        return "hqbilling/active_currency"


class TaxRateByCountry(Document, UpdatableItemMixin):
    """
        Holds the tax rate by country name (case insensitive).
    """
    country = StringProperty(default="")
    tax_rate = DecimalProperty()

    @property
    def column_list(self):
        return ["country", "tax_rate"]

    @property
    def update_item_button(self):
        return '<a href="#updateRateModal" class="btn" onclick="rateUpdateManager.updateRate(this)" data-rateid="%s" data-toggle="modal">Edit</a>' % self._id

    def _format_property(self, key, property):
        if key == "tax_rate":
            return "%.2f%%" % property
        if key == "country":
            return property if property else "Applies to All Countries"
        return super(TaxRateByCountry, self)._format_property(key, property)

    @classmethod
    def get_tax_info(cls, country, subtotal):
        rate = cls.get_by_country(country).first()
        if not rate:
            rate = cls.get_default()
        tax_applied = subtotal * rate.tax_rate
        total = subtotal + tax_applied
        fmt = "$%.2f"
        return dict(
            subtotal=dict(val=subtotal, html=fmt % subtotal),
            percent=dict(val=rate.tax_rate, html="%.2f%%" % rate.tax_rate),
            applied=dict(val=tax_applied, html=fmt % tax_applied),
            total=dict(val=total, html=fmt % total)
        )

    @classmethod
    def get_by_country(cls, country, include_docs=True):
        return cls.view("hqbilling/tax_rates",
            reduce=False,
            include_docs=include_docs,
            startkey=[country],
            endkey=[country, {}]
        )

    @classmethod
    def update_item_from_form(cls, **kwargs):
        country = kwargs.get('country', '').lower()
        tax_rate = kwargs.get('tax_rate', 0)
        rate = cls.get_by_country(country).first()
        if not rate:
            rate = cls()
            rate.country = country
        rate.tax_rate = tax_rate
        rate.save()
        return rate

    @classmethod
    def get_default(cls, include_docs=True):
        return cls.get_by_country("", include_docs).first()

    @staticmethod
    def couch_view():
        return "hqbilling/tax_rates"


class SMSRate(Document, UpdatableItemMixin):
    direction = StringProperty()
    last_modified = DateTimeProperty()
    currency_code = StringProperty(default=settings.DEFAULT_CURRENCY)
    base_fee = DecimalProperty()

    @property
    def currency_character(self):
        return "$"

    @property
    def column_list(self):
        return ["direction", "base_fee"]

    @property
    def update_item_button(self):
        return '<a href="#updateRateModal" class="btn" onclick="rateUpdateManager.updateRate(this)" data-rateid="%s" data-toggle="modal">Edit</a>' % self._id

    @property
    def default_base_fee(self):
        return DEFAULT_BASE

    @property
    def billable_amount(self):
        return self.base_fee

    @property
    def conversion_rate(self):
        rate = 0.0
        try:
            r = BillableCurrency.get_by_code(self.currency_code)
            rate = r.conversion
        except Exception as e:
            logging.error("Could not get conversion rate. Error: %s" % e)
        return decimal.Decimal(rate)

    def _format_property(self, key, property):
        if key == "direction":
            return SMS_DIRECTIONS[property]
        if isinstance(property, decimal.Decimal):
            property = property.quantize(decimal.Decimal(10) ** -3)
            return "%s %s" % (self.currency_character, property)
        return super(SMSRate, self)._format_property(key, property)

    def update_item_from_form(self, overwrite=True, **kwargs):
        self.direction = kwargs.get('direction', OUTGOING)
        if overwrite:
            self.currency_code = self.currency_code_setting()
            self.last_modified = datetime.datetime.utcnow()
            self.base_fee = self.correctly_format_rate(kwargs.get('base_fee', self.default_base_fee))
        self.save()

    @classmethod
    def get_by_match(cls, match_key, include_docs=True):
        rate = cls.view(cls.couch_view(),
            reduce=False,
            include_docs=include_docs,
            startkey=match_key,
            endkey=match_key+[{}],
        ).first()
        return rate

    @classmethod
    def update_item_from_form_by_match(cls, overwrite=True, **kwargs):
        rate = cls.get_by_match(cls.generate_match_key(**kwargs))
        if not rate:
            rate = cls()
            overwrite = True
        rate.update_item_from_form(overwrite, **kwargs)
        return rate

    @staticmethod
    def currency_code_setting():
        return settings.DEFAULT_CURRENCY

    @staticmethod
    def generate_match_key(**kwargs):
        return [str(kwargs.get('direction', 'I'))]

    @staticmethod
    def correctly_format_rate(rate):
        if isinstance(rate, str):
            rate = "%f" % rate
        return rate

    @staticmethod
    def correctly_format_code(code):
        if isinstance(code, float) or isinstance(code, int):
            code = "%d" % code
        return code


class MachSMSRate(SMSRate):
    """
        Generated with each inbound/outbound sms via Mach's API.
    """
    country_code = StringProperty()
    country = StringProperty()
    iso = StringProperty()
    mcc = StringProperty()
    mnc = StringProperty()
    network = StringProperty()
    network_surcharge = DecimalProperty()

    @property
    def currency_character(self):
        return "&euro;"

    @property
    def column_list(self):
        return ["direction",
                "country",
                "network",
                "iso",
                "country_code",
                "mcc",
                "mnc",
                "base_fee",
                "network_surcharge"]

    @property
    def billable_amount(self):
        return self.base_fee + self.network_surcharge

    def update_item_from_form(self, overwrite=True, **kwargs):
        self.network_surcharge = self.correctly_format_rate(kwargs.get('network_surcharge', 0))
        self.mcc = kwargs.get('mcc')
        self.mnc = kwargs.get('mnc')
        self.country_code = kwargs.get('country_code')
        if overwrite:
            self.country = kwargs.get('country', '')
            self.network = kwargs.get('network', '')
            self.iso = str(kwargs.get('iso', ''))
        super(MachSMSRate, self).update_item_from_form(overwrite, **kwargs)

    @classmethod
    def update_item_from_form_by_match(cls, overwrite=True, **kwargs):
        kwargs['country_code'] = cls.correctly_format_code(kwargs.get('country_code', ''))
        kwargs['mcc'] = cls.correctly_format_code(kwargs.get('mcc', ''))
        kwargs['mnc'] = cls.correctly_format_code(kwargs.get('mnc', ''))
        return super(MachSMSRate, cls).update_item_from_form_by_match(overwrite, **kwargs)

    @staticmethod
    def currency_code_setting():
        return "EUR"

    @staticmethod
    def couch_view():
        return "hqbilling/mach_rates"

    @staticmethod
    def generate_match_key(**kwargs):
        return [kwargs.get('direction', OUTGOING),
                kwargs.get('country', ''),
                kwargs.get('network', '')]

    @classmethod
    def get_by_number(cls, direction, mach_number, include_docs=True):
        match_key = cls.generate_match_key(**dict(
            direction=direction,
            network=mach_number.network,
            country=mach_number.country
        ))
        return cls.get_by_match(match_key, include_docs)


class TropoSMSRate(SMSRate):
    """
        This is a billing rate for SMSs sent via Tropo.
    """
    country_code = StringProperty()

    @property
    def column_list(self):
        return ["direction",
                "country_code",
                "base_fee"]

    def _format_property(self, key, property):
        if key == "country_code":
            return property if property else "Applies to All Non-Matching Projects"
        return super(TropoSMSRate, self)._format_property(key, property)

    def update_item_from_form(self, overwrite=True, **kwargs):
        self.country_code = self.correctly_format_code(kwargs.get("country_code", ''))
        super(TropoSMSRate, self).update_item_from_form(overwrite, **kwargs)

    @classmethod
    def get_default_rate(cls, direction, include_docs=True):
        key = [direction, ""]
        return cls.view(cls.couch_view(),
            reduce=False,
            include_docs=include_docs,
            startkey=key,
            endkey=key+[{}]
        )

    @staticmethod
    def couch_view():
        return "hqbilling/tropo_rates"

    @staticmethod
    def generate_match_key(**kwargs):
        return [kwargs.get('direction', OUTGOING),
                kwargs.get('country_code', '')]


class UnicelSMSRate(SMSRate):
    """
        This is a billing rate for SMSs sent via Unicel.
    """
    @staticmethod
    def couch_view():
        return "hqbilling/unicel_rates"


class DimagiDomainSMSRate(SMSRate):
    """
        This is the Dimagi SMS surcharge configured on a per domain level
    """
    domain = StringProperty()

    @property
    def column_list(self):
        return ["domain",
                "direction",
                "base_fee"]

    def update_item_from_form(self, overwrite=True, **kwargs):
        self.domain = self.correctly_format_code(kwargs.get("domain", ''))
        super(DimagiDomainSMSRate, self).update_item_from_form(overwrite, **kwargs)

    @staticmethod
    def couch_view():
        return "hqbilling/dimagi_rates"

    @staticmethod
    def generate_match_key(**kwargs):
        return [kwargs.get('direction', OUTGOING),
                kwargs.get('domain', '')]


class MachPhoneNumber(Document):
    phone_number = StringProperty()
    network = StringProperty()
    country = StringProperty()

    @classmethod
    def get_by_number(cls, number, api_info):
        try:
            [country, network] = api_info[-2].strip().split('  ')
        except Exception:
            country = None
            network = None
        try:
            mach_number = cls.view("hqbilling/mach_phone_numbers",
                reduce=False,
                include_docs=True,
                startkey=[number],
                endkey=[number,{}]
            ).first()
            if not mach_number:
                mach_number = cls()
            if country and network:
                mach_number.country = country
                mach_number.network = network
                mach_number.save()
            return mach_number
        except Exception as e:
            logging.error("Error retrieving mach phone number: %s" % e)
            return None


class SMSBillable(Document):
    """
        One of these is generated every time an SMS is successfully sent or received.
        The cost is generated at the time the SMS is sent or received.
    """
    billable_date = DateTimeProperty()
    # billable amount is not converted into USD, stays in the billing rate's currency
    # this is the amount that the SMS backend is billing Dimagi
    billable_amount = DecimalProperty()
    # conversion rate at the time of creating the billable item
    # this applies only to the billable amount
    conversion_rate = DecimalProperty()
    # the dimagi surcharge is always in USD and is the amount we may or may not add on top of the billable amount
    # based on the domain used
    dimagi_surcharge = DecimalProperty(default=0)

    rate_id = StringProperty()
    log_id = StringProperty()

    # Summary Info
    domain = StringProperty()
    direction = StringProperty()
    phone_number = StringProperty()

    @property
    def api_name(self):
        return "All"

    @property
    def converted_billable_amount(self):
        return self.billable_amount * self.conversion_rate

    @property
    def total_billed(self):
        return self.converted_billable_amount + self.dimagi_surcharge

    def _calculate_surcharge(self, message):
        match_key = DimagiDomainSMSRate.generate_match_key(**dict(
            direction=message.direction,
            domain=message.domain
        ))
        dimagi_rate = DimagiDomainSMSRate.get_by_match(match_key)
        self.dimagi_surcharge = dimagi_rate.base_fee if dimagi_rate else 0

    def calculate_rate(self, rate_item, message):
        if rate_item:
            self.billable_date = datetime.datetime.utcnow()
            self.billable_amount = rate_item.billable_amount
            self.conversion_rate = rate_item.conversion_rate
            self.rate_id = rate_item._id
            self._calculate_surcharge(message)
            message.billed = True
            message.save()

    def save_message_info(self, message):
        self.log_id = message.get_id
        self.domain = message.domain
        self.direction = message.direction
        self.phone_number = message.phone_number

    @classmethod
    def couch_view(cls):
        return "hqbilling/all_billable_items"

    @classmethod
    def get_all(cls, include_docs=True):
        return cls.view(cls.couch_view(),
            reduce=False,
            include_docs = include_docs
        )

    @classmethod
    def by_domain(cls, domain, include_docs=True, start=None, end=None):
        key =["domain", domain]
        startkey_suffix, endkey_suffix = format_start_end_suffixes(start, end)
        return cls.view(cls.couch_view(),
            reduce=False,
            include_docs = include_docs,
            startkey = key+startkey_suffix,
            endkey = key+endkey_suffix)

    @classmethod
    def by_domain_and_direction(cls, domain, direction, include_docs=True, start=None, end=None):
        key =["domain direction", domain, direction]
        startkey_suffix, endkey_suffix = format_start_end_suffixes(start, end)
        return cls.view(cls.couch_view(),
            reduce=False,
            include_docs = include_docs,
            startkey = key+startkey_suffix,
            endkey = key+endkey_suffix
        )

    @classmethod
    def handle_api_response(cls, message, **kwargs):
        if message.billing_errors:
            logging.error("ERRORS billing SMS Message with ID %s:\n%s" % (message._id, "\n".join(message.billing_errors)))
            message.save()

    @classmethod
    def save_from_message(cls, rate_item, message):
        billable = None
        if rate_item:
            billable = cls()
            billable.calculate_rate(rate_item, message)
            billable.save_message_info(message)
            billable.save()
        else:
            message.billing_errors.append("Billing rate entry could not be found.")
        return dict(billable=billable, message=message)


class UnicelSMSBillable(SMSBillable):
    """
        Generated when an SMS is sent or received via Unicel's API.
    """
    unicel_id = StringProperty()

    @property
    def api_name(self):
        return "Unicel"

    @classmethod
    def couch_view(cls):
        return "hqbilling/unicel_billable_items"

    @classmethod
    def handle_api_response(cls, message, **kwargs):
        response = kwargs.get('response', None)
        match_key = UnicelSMSRate.generate_match_key(**dict(direction=message.direction))
        rate_item = UnicelSMSRate.get_by_match(match_key)
        if not rate_item:
            message.billing_errors.append("No Unicel rate item could be found for key: %s" % match_key)
        elif isinstance(response, str) and len(response) > 0:
            # attempt to figure out if there was an error in sending the message.
            # Look for something like '0x200 - ' in the returned string
            # A successful return will just be a uuid from Unicel.
            find_err = re.compile('\dx\d\d\d\s-\s')
            match = find_err.search(response)
            if not match:
                result = cls.save_from_message(rate_item, message)
                billable = result.get('billable', None)
                if billable:
                    billable.unicel_id = response
                    billable.save()
                    return
                else:
                    message.billing_errors.extend(result.get('message', []))
            else:
                message.billing_errors.append("Attempted to send message via UNICEL api and received errors. Client not billed. Errors: %s" % response)
        elif message.direction == INCOMING:
            result = cls.save_from_message(rate_item, message)
            billable = result.get('billable', None)
            if billable:
                billable.unicel_id = "incoming"
                billable.save()
                return
        else:
            message.billing_errors.append("Attempt to send message via UNICEL api resulted in an error.")
        super(UnicelSMSBillable, cls).handle_api_response(message, **kwargs)


class TropoSMSBillable(SMSBillable):
    """
        Generated when an SMS is sent via Tropo's API.
    """
    tropo_id = StringProperty()

    @property
    def api_name(self):
        return "Tropo"

    @classmethod
    def couch_view(cls):
        return "hqbilling/tropo_billable_items"

    @classmethod
    def handle_api_response(cls, message, **kwargs):
        response = kwargs.get("response")
        find_success = re.compile('(<success>).*(</success>)')
        match = find_success.search(response)
        successful = bool(match and match.group() == '<success>true</success>')
        if successful:
            number = phonenumbers.parse(message.phone_number)
            rate_item = TropoSMSRate.get_by_match(
                TropoSMSRate.generate_match_key(**dict(direction=message.direction,
                    country_code="%d" % number.country_code
                )))
            if not rate_item:
                rate_item = TropoSMSRate.get_default_rate(message.direction).first()
            result = cls.save_from_message(rate_item, message)
            billable = result.get('billable', None)
            if billable:
                billable.tropo_id = cls.get_tropo_id(response)
                billable.save()
        else:
            message.billing_errors.append("An error occurred while sending a message through the Tropo API.")
        super(TropoSMSBillable, cls).handle_api_response(message, **kwargs)

    @classmethod
    def get_tropo_id(cls, response):
        id_reg = re.compile('(<id>[a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]+)')
        match = id_reg.search(response)
        if match and len(match.group()) > 4:
            return match.group()[4:]
        return None


class MachSMSBillable(SMSBillable):
    """
        Generated when an SMS is sent or received via Mach's API.
    """
    contacted_mach_api = DateTimeProperty()
    sync_attempts = ListProperty()
    mach_delivery_status = StringProperty()
    mach_id = StringProperty()
    mach_delivered_date = DateTimeProperty()

    @property
    def api_name(self):
        return "Mach"

    def save_message_info(self, message):
        self.sync_attempts.append(datetime.datetime.utcnow())
        super(MachSMSBillable, self).save_message_info(message)

    def update_mach_delivery_status(self, api_info):
        delivered_on = api_info[-3]
        delivery_status = api_info[-1]
        mach_id = api_info[0]
        if delivered_on:
            delivered_on = delivered_on.replace(". ", ".%s " % datetime.datetime.now().year)
            try:
                delivered_on = datetime.datetime.strptime(delivered_on, "%d.%m.%Y %H:%M:%S")
                berlin = pytz.timezone('Europe/Berlin')
                is_dst = tz_utils.is_timezone_in_dst(berlin, delivered_on)
                delivered_on = berlin.localize(delivered_on, is_dst=is_dst).astimezone(pytz.utc)
                contact = datetime.datetime.replace(self.contacted_mach_api, tzinfo=pytz.utc)
                td = contact-delivered_on
                total_seconds = abs(td.seconds + td.days * 24 * 3600)
                existing = self.get_by_mach_id(mach_id)
                # allowing three minutes of latency and making sure that the mach_id is unique
                if total_seconds <= 60*3 and not existing:
                    self.mach_id = mach_id
                    self.mach_delivery_status = delivery_status
                    self.mach_delivered_date = delivered_on
            except Exception as e:
                logging.info("Error parsing mach API delivery info: %s" % e)
        elif delivery_status == 'accepted':
            # message has not been delivered yet
            self.mach_id = mach_id
            self.mach_delivery_status = delivery_status

    @classmethod
    def couch_view(cls):
        return "hqbilling/mach_billable_items"

    @classmethod
    def get_by_mach_id(cls, mach_id, include_docs=True):
        return cls.view("hqbilling/mach_billable_items_by_mach_id",
            reduce=False,
            include_docs=include_docs,
            startkey=[mach_id],
            endkey=[mach_id, {}]
        )

    @classmethod
    def get_rateless(cls, include_docs=True):
        return cls.view('hqbilling/mach_billable_rateless',
            reduce=False,
            include_docs=include_docs
        )

    @classmethod
    def get_statusless(cls, include_docs=True):
        return cls.view('hqbilling/mach_billable_statusless',
            reduce=False,
            include_docs=include_docs
        )

    @classmethod
    def handle_api_response(cls, message, **kwargs):
        response = kwargs.get('response', None)
        if isinstance(response, str) or isinstance(response, unicode):
            api_success = bool("+OK" in response)
            if api_success:
                test_mach_data = kwargs.get('_test_scrape')
                mach_data = test_mach_data if test_mach_data else get_mach_data()
                if mach_data:
                    last_message = mach_data[0]
                    phone_number = last_message[3]
                    billable = cls()
                    billable.save_message_info(message)
                    billable.contacted_mach_api = datetime.datetime.now(tz=pytz.utc)
                    if phone_number == message.phone_number:
                        # same phone number, now check delivery date
                        billable.update_mach_delivery_status(last_message)
                    mach_number = MachPhoneNumber.get_by_number(message.phone_number, last_message)
                    if mach_number:
                        rate_item = MachSMSRate.get_by_number(message.direction, mach_number)
                        billable.calculate_rate(rate_item, message)
                    billable.save()
                else:
                    message.billing_errors.append("There was an error retrieving message delivery information from Mach.")
            else:
                message.billing_errors.append("There was an error accessing the MACHI API.")
        else:
            message.billing_errors.append("There was an error while trying to send an SMS to via Mach.")
        super(MachSMSBillable, cls).handle_api_response(message, **kwargs)


